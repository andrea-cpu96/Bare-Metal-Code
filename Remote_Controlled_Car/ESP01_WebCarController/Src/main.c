/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <string.h>

#include "projectconf.h"
#include "systemfunctions.h"
#include "ports.h"

#include "uart.h"

#include "main.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uartHandler_t huart1;
uartHandler_t huart2;

uint8_t esp01CurrentState = USER_SEND_TO_ESP01;
uint8_t esp01NextState = USER_SEND_TO_ESP01;

uint8_t c;
uint8_t CharacterReceived; // Flag to receive next character

uint8_t commandNumber;

uint32_t delayTimeStamp;


int main(void)
{

	huart1.uart_Istance = UART_1;
	huart2.uart_Istance = UART_2;


	// System configurations
	System_Config();

	// Uart configuration
	uart_Init_It(&huart1);
	uart_Init_It(&huart2);


	uart_Start_Tx_It(&huart2, (uint8_t *)"Communication started:\r\n", 24);
	uart_Start_Rx_It(&huart1, &c, 1);

	uint32_t *pGPIOXODR = (uint32_t *)( (uint32_t)0x40020000U + (uint32_t)0x14 );

	while (1)
	{

		// Loop here until the user enter a new command

		if(CharacterReceived)
		{

			CharacterReceived = 0; // Reset of the flag


			switch(commandNumber)
			{

				default:
				case STOP:

					*pGPIOXODR &= ~( 0x000018C0U );

					break;

				case GO_AHEAD:

					*pGPIOXODR &= ~( 0x000018C0U );

					*pGPIOXODR |= ( 1 << 6 );
					*pGPIOXODR &= ~( 1 << 7 );

					*pGPIOXODR |= ( 1 << 11 );
					*pGPIOXODR &= ~( 1 << 12 );

					break;

				case GO_BACK:

					*pGPIOXODR &= ~( 0x000018C0U );

					*pGPIOXODR &= ~( 1 << 6 );
					*pGPIOXODR |= ( 1 << 7 );

					*pGPIOXODR &= ~( 1 << 11 );
					*pGPIOXODR |= ( 1 << 12 );

					break;

				case TURN_RIGHT:

					*pGPIOXODR &= ~( 0x000018C0U );

					*pGPIOXODR &= ~( 1 << 6 );
					*pGPIOXODR &= ~( 1 << 7 );

					*pGPIOXODR |= ( 1 << 11 );
					*pGPIOXODR &= ~( 1 << 12 );

					break;

				case TURN_LEFT:

					*pGPIOXODR &= ~( 0x000018C0U );

					*pGPIOXODR |= ( 1 << 6 );
					*pGPIOXODR &= ~( 1 << 7 );

					*pGPIOXODR &= ~( 1 << 11 );
					*pGPIOXODR &= ~( 1 << 12 );

					break;

				case GARBAGE1: // /n
				case GARBAGE2: // /r
					break;

			}

			delayTimeStamp = Get_SystemTimeMs();

			while(Compare_SystemTimeMs(delayTimeStamp) < 1000);

			uart_Start_Tx_It(&huart2, (uint8_t *)"\n\r", 2);
				uart_Start_Rx_It(&huart1, &c, 1);

		}

	}



}

void SysTick_CallBack(void)
{

	SysTickCountMs++;

}

void USART_ApplicationEventCallback(uartHandler_t *huart, uint8_t event)
{


	if(event == USART_EVENT_RX_CMPLT)
	{

		// Check which uart issued the interrupt
		if(huart->uart_Istance == huart1.uart_Istance)
		{

			// Print out the command entered

			uart_Start_Tx_It(&huart2, &c, 1);

			commandNumber = c;

			CharacterReceived = 1; // Flag for next character

		}


	}

}

